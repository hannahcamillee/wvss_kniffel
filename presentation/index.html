<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Kniffel</title>
  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/night.css">
  <link rel="icon" href="assets/" type="image/x-icon">
  <link rel="stylesheet" href="plugin/highlight/monokai.css">
  <link rel="stylesheet" href="plugin/highlight/zenburn.css">
  <style>
    .reveal .slides section .fragment.highlight-current-red.current-fragment {
      color: #ff6b6b;
    }
    body, .reveal, .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
      font-family: 'Source Sans Pro', Helvetica, Arial, sans-serif !important;
      font-weight: 400;
    }
    .reveal h1 {
      font-size: 2.2em !important;
      font-weight: 700;
      margin-bottom: 0.2em;
      letter-spacing: 0.01em;
    }
    .reveal h3 {
      font-size: 1.2em !important;
      font-weight: 400;
      margin-bottom: 1.2em;
      letter-spacing: 0.01em;
    }
    .tech-stack {
      display: flex;
      justify-content: space-around;
      align-items: center;
      margin: 20px 0;
    }
    .tech-item {
      text-align: center;
      margin: 0 10px;
    }
    .game-rules {
      font-size: 0.8em;
      text-align: left;
    }
    .architecture-diagram {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 20px 0;
    }
    .layer {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 10px;
      margin: 0 10px;
      flex: 1;
    }
    .checklist {
      list-style: none !important;
      padding-left: 0;
      margin-left: 0;
    }
    .checklist li {
      list-style: none !important;
      margin-left: 0;
      padding-left: 0.5em;
      position: relative;
    }
    .checklist li::before {
      content: "‚úî ";
      color: #4caf50;
      font-weight: bold;
    }
    .challenge-solution {
      display: flex;
      gap: 40px;
      flex-wrap: wrap;
    }
    .challenge-solution > div {
      flex: 1 1 300px;
      min-width: 250px;
    }
    .architecture-diagram {
      display: flex;
      justify-content: space-between;
      align-items: stretch;
      margin: 20px 0;
      gap: 1em;
    }
    .layer {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 10px;
      margin: 0 10px;
      flex: 1 1 0;
      min-width: 220px;
      min-height: 180px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .reveal {
    background: #18243a !important; /* Sattes Dunkelblau */
    }
    .reveal .slides {
      background: transparent !important;
    }
    .reveal, .reveal .slides, .reveal section {
      color: #e6eaf3 !important;
    }
    .reveal h1, .reveal h2, .reveal h3 {
      margin-bottom: 0.5em;
      letter-spacing: 0.01em;
    }
    .reveal ul, .reveal ol {
      font-size: 0.97em;
      margin-bottom: 0.5em;
    }
    .reveal pre code {
      font-size: 0.92em;
      border-radius: 8px;
      background: #232e47 !important;
      color: #e6eaf3 !important;
      padding: 1em;
    }
    figcaption {
      color: #b0b8c9;
      font-size: 0.95em;
      margin-top: 0.3em;
    }
    .checklist li::before {
      color: #4fc3f7;
    }
    .fragment {
      transition: opacity 0.5s, transform 0.5s;
    }
    .team-roles {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 2em;
    margin-bottom: 1em;
    align-items: stretch;
    width: 100%;
  }
  .team-roles > div {
    min-width: 260px;
    max-width: 340px;
    font-size: 0.82em;
    flex: 1 1 0;
    background: rgba(255,255,255,0.07);
    border-radius: 12px;
    padding: 1em 1.2em 1em 1.2em;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    font-size: 0.92em;
    overflow: visible;
    word-break: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
    height: auto;
  }
  .team-roles h4 {
    margin-top: 0;
    margin-bottom: 0.5em;
    font-size: 1em;
    font-weight: 700;
    color: #4fc3f7;
    white-space: normal;
  }
  .team-roles ul {
    margin: 0;
    padding-left: 1.1em;
    font-size: 0.8em;
    list-style: disc;
    color: #e6eaf3;
  }
  .team-roles li {
    margin-bottom: 0.18em;
    line-height: 1.22;
  }
  @media (max-width: 1100px) {
    .team-roles {
      flex-direction: column;
      align-items: stretch;
      gap: 1em;
    }
    .team-roles > div {
      width: 100%;
      min-width: 0;
      max-width: 100vw;
    }
  }
  </style>
</head>
<body>
  <div class="reveal">
    <div class="slides">
      
      <!-- Title Slide -->
      <section>
        <h1 style="font-size:2.5em;font-family:'Source Sans Pro',Helvetica,sans-serif;margin-bottom:0.3em;">üé≤ Kniffel Web-App</h1>
        <h3 style="font-size:1.3em;font-family:'Source Sans Pro',Helvetica,sans-serif;margin-bottom:1em;">Online W√ºrfelspiel mit Registrierung & Highscore</h3>
        <p>
          <small>Entwickelt von: Camille, Lars & Lukas</small>
        </p>
      </section>

      <!-- Projektziel -->
      <section>
        <h2>üéØ Projektziel</h2>
        <ul>
          <li class="fragment">Kniffel als Web-App spielbar</li>
          <li class="fragment">Registrierung & Login</li>
          <li class="fragment">Alle Kniffel-Regeln integriert</li>
          <li class="fragment">Highscore (Top 10)</li>
          <li class="fragment">Responsive f√ºr alle Ger√§te</li>
        </ul>
        <aside class="notes">
          <strong>Lars:</strong> Unser Ziel war es, das bekannte W√ºrfelspiel Kniffel als moderne Web-App umzusetzen. 
          Das bedeutet: Das Spiel sollte komplett online spielbar sein, inklusive Registrierung und Login, damit jeder Nutzer seine eigenen Spiele und Highscores verwalten kann. 
          Wir wollten alle offiziellen Kniffel-Regeln abbilden, also sowohl die obere als auch die untere H√§lfte des Spielblocks, inklusive Bonusregel. 
          Ein weiteres Ziel war eine Highscore-Liste, in der die besten 10 Spieler angezeigt werden. 
          Und ganz wichtig: Die App sollte auf allen Ger√§ten funktionieren, also auch auf Smartphones und Tablets, damit jeder √ºberall spielen kann.
        </aside>
      </section>

      <!-- Muss-Kriterien Checkliste -->
      <section>
        <h2>‚úÖ Muss-Kriterien</h2>
        <ul class="checklist">
          <li class="fragment">Registrierung & Login/Logout</li>
          <li class="fragment">Kniffel-Spiel mit 5 W√ºrfeln, 3 W√ºrfen, W√ºrfel halten</li>
          <li class="fragment">Automatische Punktevergabe & Kategorien</li>
          <li class="fragment">Spielstand speichern & Highscore-Liste</li>
          <li class="fragment">Eigene Spielhistorie</li>
        </ul>
        <aside class="notes">
          <strong>Lukas:</strong> 
          <p>Hier seht ihr die wichtigsten Muss-Kriterien, die wir umgesetzt haben.</p>
          <ol>
            <li>Erstens: Jeder Nutzer kann sich registrieren, einloggen und auch wieder ausloggen.</li>
            <li>Zweitens: Das eigentliche Kniffel-Spiel l√§uft mit 5 W√ºrfeln, pro Runde darf man bis zu 3-mal w√ºrfeln und beliebige W√ºrfel halten.</li>
            <li>Drittens: Die Punkte werden automatisch berechnet und den richtigen Kategorien zugeordnet, sodass niemand selbst rechnen muss.</li>
            <li>Viertens: Nach jedem Spiel wird der Spielstand gespeichert und die Highscore-Liste aktualisiert.</li>
            <li>Und schlie√ülich kann jeder Nutzer seine eigene Spielhistorie einsehen, also alle bisherigen Spiele und deren Ergebnisse.</li>
          </ol>
        </aside>
      </section>

      <!-- Kniffel-Regeln -->
      <section>
        <section>
          <h2>üé≤ Kniffel-Regeln</h2>
          <ul>
            <li class="fragment">5 W√ºrfel, bis zu 3 W√ºrfe pro Runde</li>
            <li class="fragment">Nach jedem Wurf beliebige W√ºrfel halten</li>
            <li class="fragment">Am Ende jeder Runde: Kategorie w√§hlen und Punkte eintragen</li>
            <li class="fragment">Obere H√§lfte: Einser‚ÄìSechser, Bonus ab 63 Punkten (+35)</li>
          </ul>
          <aside class="notes">
            <strong>Camille:</strong> F√ºr alle, die Kniffel nicht kennen: 
            Man spielt mit 5 W√ºrfeln. In jeder Runde darf man bis zu 3-mal w√ºrfeln. 
            Nach jedem Wurf kann man beliebige W√ºrfel "halten", also beiseitelegen, und nur die √ºbrigen nochmal w√ºrfeln. 
            Am Ende der Runde muss man sich f√ºr eine Kategorie entscheiden und die Punkte dort eintragen. 
            In der oberen H√§lfte gibt es die Kategorien Einser bis Sechser. 
            Wenn man dort insgesamt mindestens 63 Punkte erreicht, bekommt man einen Bonus von 35 Punkten.
          </aside>
        </section>

        <section>
          <ul>
            <li>Untere H√§lfte: Dreierpasch, Viererpasch, Full House, Kleine/Gro√üe Stra√üe, Kniffel, Chance</li>
            <li class="fragment">Alle Felder belegt = Spielende</li>
            <li class="fragment">H√∂chste Punktzahl gewinnt</li>
          </ul>
          <aside class="notes">
            <strong>Lars:</strong> In der unteren H√§lfte gibt es weitere Kategorien: 
            Dreierpasch, Viererpasch, Full House, Kleine und Gro√üe Stra√üe, Kniffel und Chance. 
            Jede Kategorie kann nur einmal belegt werden. 
            Das Spiel endet, wenn alle Felder ausgef√ºllt sind.
            Gewonnen hat, wer am Ende die h√∂chste Punktzahl erreicht hat.
          </aside>
        </section>
      </section>

      <!-- Technik√ºbersicht -->
      <section>
        <h2>‚öô Technik√ºbersicht</h2>
        <div class="architecture-diagram" style="gap:1em;">
          <div class="layer fragment">
            <h4>Frontend</h4>
            <ul>
              <li>React + Vite</li>
              <li>Tailwind CSS</li>
              <li>JavaScript ES6+</li>
            </ul>
          </div>
          
          <div class="layer fragment">
            <h4>Backend</h4>
            <ul>
              <li>Node.js + Express</li>
              <li>Session-Auth</li>
              <li>RESTful API</li>
            </ul>
          </div>

          <div class="layer fragment">
            <h4>Datenbank</h4>
            <ul>
              <li>SQLite</li>
              <li>Prisma ORM</li>
             <li>Migrations</li>
            </ul>
          </div>
        </div>
        <aside class="notes">
          <strong>Lukas:</strong> F√ºr die Umsetzung haben wir moderne Technologien gew√§hlt. 
          Im Frontend setzen wir auf React mit Vite f√ºr schnelle Entwicklung und Tailwind CSS f√ºr das Styling. 
          Die Spiellogik und die Interaktivit√§t laufen komplett im Browser mit JavaScript ES6+. 
          Im Backend nutzen wir Node.js mit Express, um eine REST-API bereitzustellen. 
          Die Authentifizierung l√§uft √ºber Sessions, damit Nutzer sicher eingeloggt bleiben. 
          F√ºr die Datenhaltung verwenden wir SQLite als Datenbank und Prisma als ORM, um einfach und sicher auf die Daten zuzugreifen und Migrationen durchzuf√ºhren.
        </aside>
      </section>

      <!-- Projektstruktur -->
      <section>
        <section>
          <h2>üìÅ Projektstruktur</h2>
          <p>Klare Trennung zwischen Frontend und Backend</p>
          <aside class="notes">
            <strong>Camille:</strong> Die Projektstruktur ist klar getrennt: 
            Das Frontend und das Backend sind jeweils in eigenen Ordnern organisiert. 
            Das erleichtert die Entwicklung, weil jeder Bereich unabh√§ngig weiterentwickelt und getestet werden kann. 
            Au√üerdem k√∂nnen wir so das Backend sp√§ter auch f√ºr andere Clients nutzen, zum Beispiel f√ºr eine mobile App.
          </aside>
        </section>

        <section>
          <h3>Backend Struktur</h3>
          <pre><code class="language-js" data-trim>
server/
‚îú‚îÄ‚îÄ index.js            // App-Startpunkt
‚îú‚îÄ‚îÄ routes/             // API-Routen
‚îú‚îÄ‚îÄ middleware/         // Authentifizierung & Fehlerbehandlung
‚îú‚îÄ‚îÄ prisma/             // Datenbank & Schema
‚îú‚îÄ‚îÄ utils/              // Hilfsfunktionen
‚îî‚îÄ‚îÄ .env                // Umgebungsvariablen
          </code></pre>
          <aside class="notes">
            <strong>Lars:</strong> Im Backend gibt es einen zentralen Einstiegspunkt, die index.js. 
            Die API-Routen sind in einem eigenen Verzeichnis organisiert, zum Beispiel f√ºr Authentifizierung und Score. 
            Die Middleware enth√§lt Funktionen f√ºr Authentifizierung und Fehlerbehandlung. 
            Im prisma-Ordner liegt das Datenbankschema und die Migrationen. 
            Hilfsfunktionen, zum Beispiel f√ºr die Validierung, sind in utils ausgelagert. 
            Die Umgebungsvariablen wie Datenbankpfad oder Session-Secret stehen in der .env-Datei.
          </aside>
        </section>

        <section>
          <h3>Frontend Struktur</h3>
            <pre><code data-trim>
client/
‚îú‚îÄ‚îÄ src/                // React-Quellcode
‚îÇ   ‚îú‚îÄ‚îÄ components/     // UI-Komponenten
‚îÇ   ‚îú‚îÄ‚îÄ pages/          // Seiten
‚îÇ   ‚îú‚îÄ‚îÄ utils/          // Logik
‚îú‚îÄ‚îÄ public/             // Statische Assets
‚îú‚îÄ‚îÄ index.html          // HTML-Template
‚îî‚îÄ‚îÄ vite.config.js      // Vite-Konfiguration
            </code></pre>
            <aside class="notes">
              <strong>Lukas:</strong> Das Frontend ist ebenfalls klar strukturiert. 
              Im src-Ordner liegen alle React-Komponenten, die einzelnen Seiten und die Hilfsfunktionen. 
              Die Komponenten sind wiederverwendbare UI-Bausteine, zum Beispiel f√ºr die W√ºrfel oder das Scoreboard. 
              Die Seiten bilden die verschiedenen Ansichten ab, wie das Spiel, die Highscore-Liste oder die Registrierung. 
              Im public-Ordner liegen statische Dateien wie Bilder. 
              Die index.html ist das HTML-Template, das von Vite beim Build verwendet wird. 
              Die Vite-Konfiguration steuert den Entwicklungsserver und das Build-Verhalten.
            </aside>
        </section>
      </section>

      <!-- Screenshots -->
      <section>
        <section>
          <h2>üñºÔ∏è ScreenshotsÔ∏è</h2>
          <p>Wichtige Ansichten der App</p>
          <aside class="notes">
            <strong>Camille:</strong> Wir zeigen euch jetzt ein paar Screenshots, damit ihr einen Eindruck von der App bekommt. 
          </aside>
        </section>

        <section>
          <h3>Registrierung & Login</h3>
          <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 2em;">
            <figure>
              <img src="../assets/register.png" alt="Registrieren" style="max-width: 350px; max-height: 350px;">
            </figure>
            <figure>
              <img src="../assets/login.png" alt="Login" style="max-width: 350px; max-height: 350px;">
            </figure>
          </div>
          <aside class="notes">
            <strong>Lars:</strong> Hier seht ihr die Registrierung und den Login. 
            Die Formulare sind bewusst einfach gehalten, damit man schnell starten kann. 
            Nach erfolgreicher Registrierung ist man direkt eingeloggt und kann losspielen.
            Die Authentifizierung l√§uft √ºber Sessions, sodass man auch nach einem Neuladen der Seite eingeloggt bleibt.
          </aside>
        </section>

        <section>
          <h3>Spieloberfl√§che</h3>
          <div style="display: flex; justify-content: center;">
            <figure>
              <img src="../assets/game.png" alt="Spiel" style="max-width: 350px; max-height: 350px;">
            </figure>
          </div>
          <aside class="notes">
            <strong>Lukas:</strong> Das ist die Hauptspieloberfl√§che. 
            Oben sieht man die aktuellen W√ºrfel, darunter die Buttons zum W√ºrfeln und Halten. 
            Die Kategorien und die aktuellen Punkte werden √ºbersichtlich angezeigt. 
            Die Punkte werden automatisch berechnet und angezeigt, sobald alle W√ºrfel geworfen wurden.
          </aside>
        </section>

        <section>
          <h3>Highscore</h3>
          <div style="display: flex; justify-content: center;">
            <figure>
              <img src="../assets/highscore.png" alt="Highscore" style="max-width: 350px; max-height: 350px;">
            </figure>
          </div>
          <aside class="notes">
            <strong>Camille:</strong> Die Highscore-Liste zeigt die besten 10 Spieler mit ihren Punktzahlen. 
            Nach jedem Spiel wird der Score automatisch gespeichert und die Liste aktualisiert. 
            So kann man sich mit anderen messen und sieht direkt, wie gut man war.
          </aside>
        </section>

        <section>
          <h3>Regeln</h3>
          <div style="display: flex; justify-content: center;">
            <figure>
              <img src="../assets/rules.png" alt="Regeln" style="max-width: 350px; max-height: 350px;">
            </figure>
          </div>
          <aside class="notes">
            <strong>Lars:</strong> F√ºr Neueinsteiger gibt es eine eigene Seite mit allen Kniffel-Regeln. 
            Hier sind alle Kategorien und die jeweiligen Punktebedingungen erkl√§rt. 
            So kann jeder sofort loslegen, auch wenn er das Spiel noch nicht kennt.
          </aside>
        </section>
      </section>

      <!-- Code-Implementierung -->
      <section>
        <section>
          <h2>üíª Code-Implementierung</h2>
          <p>Detaillierter Blick auf die technische Umsetzung</p>
          <aside class="notes">
            <strong>Lukas:</strong> Jetzt schauen wir uns an, wie wir die wichtigsten Funktionen technisch umgesetzt haben. 
            Wir zeigen euch die zentrale Punkteberechnung, das State Management im Frontend und die Erkennung von Stra√üen.
          </aside>
        </section>

        <section>
          <h3>Punkteberechnung</h3>
          <pre><code class="language-js" data-trim>
export function calculateScore(category, dice) {
  const counts = [0, 0, 0, 0, 0, 0];
  dice.forEach((d) => counts[d - 1]++);
  
  switch (category) {
    // case Ones - Fives
    case "Sixes": {
      const num = categories.indexOf(category) + 1;
      return dice.filter((d) => d === num).reduce((a, b) => a + b, 0);
    }
    case "Three of a Kind":
      return counts.some((c) => c >= 3) ? sum(dice) : 0;
    // case Four of a Kind
    case "Full House":
      return counts.includes(3) && counts.includes(2) ? 25 : 0;
    case "Small Straight":
      return hasStraight(counts, 4) ? 30 : 0;
    // case Large Straight
    case "Kniffel":
      return counts.includes(5) ? 50 : 0;
    case "Chance":
      return sum(dice);
    default:
      return 0;
  }
}
          </code></pre>
          <aside class="notes">
            <strong>Camille:</strong> Das ist die zentrale Funktion zur Punkteberechnung. Sie bekommt die gew√§hlte Kategorie und die aktuellen W√ºrfel als Parameter. Zuerst wird gez√§hlt, wie oft jede Augenzahl vorkommt. Dann pr√ºft ein Switch-Statement f√ºr jede Kategorie die passenden Bedingungen:
            <ul>
              <li>F√ºr Einser bis Sechser wird die jeweilige Augenzahl aufsummiert.</li>
              <li>Bei "Three of a Kind" und "Four of a Kind" wird gepr√ºft, ob mindestens drei bzw. vier gleiche W√ºrfel vorhanden sind. Ist das der Fall, wird die Summe aller W√ºrfel zur√ºckgegeben.</li>
              <li>F√ºr "Full House" muss es genau drei gleiche und zwei gleiche W√ºrfel geben, dann gibt es 25 Punkte.</li>
              <li>Bei "Small Straight" und "Large Straight" wird mit der Hilfsfunktion <code>hasStraight</code> gepr√ºft, ob vier bzw. f√ºnf aufeinanderfolgende Zahlen vorkommen. Daf√ºr wird die H√§ufigkeit der Augenzahlen in einen Bin√§rstring umgewandelt und mit bekannten Mustern verglichen.</li>
              <li>F√ºr "Kniffel" m√ºssen alle f√ºnf W√ºrfel gleich sein, dann gibt es 50 Punkte.</li>
              <li>Bei "Chance" wird einfach die Summe aller W√ºrfel berechnet.</li>
            </ul>
            <p>
              Die Funktion ist so aufgebaut, dass sie leicht um weitere Kategorien erweitert werden kann. 
              Au√üerdem sorgt sie daf√ºr, dass keine ung√ºltigen Punkte vergeben werden.
            </p>
          </aside>
        </section>

        <section>
          <h3>React State Management</h3>
          <pre><code class="language-js" data-trim>
const [dice, setDice] = useState(Array(5).fill(null));
const [kept, setKept] = useState(Array(5).fill(false));
const [rollsLeft, setRollsLeft] = useState(3);
const [scores, setScores] = useState(
  Object.fromEntries(categories.map((c) => [c, null]))
);
          </code></pre>
          <aside class="notes">
            <strong>Lars:</strong> Im Frontend verwalten wir den kompletten Spielzustand mit React State. 
            Wir haben einen State f√ºr die aktuellen W√ºrfel, einen f√ºr die gehaltenen W√ºrfel, einen f√ºr die verbleibenden W√ºrfe und einen f√ºr die vergebenen Punkte in den Kategorien.
          </aside>
        </section>

        <section>
          <h3>Stra√üen-Erkennung</h3>
          <pre><code class="language-js" data-trim>
export function hasStraight(counts, length) {
  const binary = counts.map((c) => (c > 0 ? 1 : 0)).join("");
  const patterns = {
    4: ["1111", "01111", "11110"], // Possible positions for small straight
    5: ["11111"],                  // Only one position for large straight
  };
  return patterns[length].some((p) => binary.includes(p));
}          
          </code></pre>
          <p><small>Mustererkennung √ºber Bin√§r-String</small></p>
          <aside class="notes">
            <strong>Lukas:</strong> Die Erkennung von kleinen und gro√üen Stra√üen ist eine der kniffligsten Aufgaben. 
            Wir wandeln die H√§ufigkeit der Augenzahlen in einen Bin√§rstring um, zum Beispiel "11111" f√ºr f√ºnf verschiedene Zahlen. 
            Dann vergleichen wir diesen String mit bekannten Mustern f√ºr kleine und gro√üe Stra√üen. 
            F√ºr die kleine Stra√üe suchen wir nach vier aufeinanderfolgenden Einsen, f√ºr die gro√üe Stra√üe nach f√ºnf. 
            Das ist sehr effizient und funktioniert unabh√§ngig davon, wie die W√ºrfel verteilt sind. 
            So k√∂nnen wir sicherstellen, dass alle g√ºltigen Stra√üen erkannt werden, auch wenn die Reihenfolge der W√ºrfel unterschiedlich ist.
          </aside>
        </section>
      </section>

      <!-- Frontend Features -->
      <section>
        <section>
          <h2>‚öõ Frontend Features</h2>
          <p>React-basierte Benutzeroberfl√§che</p>
          <aside class="notes">
            <strong>Camille:</strong> Im Frontend haben wir viele Features umgesetzt, die das Spiel besonders benutzerfreundlich machen.
          </aside>
        </section>

        <section>
          <h3>Game State Management</h3>
          <pre><code class="language-js" data-trim>
useEffect(() => {
  if (!isGameComplete) return;
  
  const upperSum = upperSectionSum(scores);
  const bonus = hasBonus(scores) ? 35 : 0;
  const totalScore = Object.values(scores)
    .reduce((sum, val) => sum + (val ?? 0), 0) + bonus;
  
  if (user) {
    axios.post("http://localhost:3001/api/score", 
      { value: totalScore }, 
      { withCredentials: true }
    ).then(() => {
      setSuccessMessage(
        `Game is complete! Your score of ${totalScore} has been saved.`
      );
    })
    .catch((error) => {
      const message =
        error.response?.data?.error || "Error saving your score";
      setErrorMessage(message);
      setTimeout(() => setErrorMessage(null), 3000);
    });
  }
}, [isGameComplete, scores, user]);
          </code></pre>
          <aside class="notes">
            <strong>Lars:</strong> Am Ende eines Spiels wird der Score automatisch berechnet und an das Backend gesendet. 
            Das passiert mit einem <code>useEffect</code>-Hook, der auf das Spielende und die vergebenen Punkte reagiert. 
            Sobald alle Kategorien belegt sind, wird die Gesamtsumme inklusive Bonus berechnet. 
            Dann wird ein POST-Request an das Backend geschickt, um den Score zu speichern. 
            Das passiert alles im Hintergrund, der Nutzer muss sich um nichts k√ºmmern. 
            Nach erfolgreichem Speichern wird eine Erfolgsmeldung angezeigt.
          </aside>
        </section>

        <section>
          <h3>Interaktives W√ºrfeln</h3>
          <pre><code class="language-js" data-trim>
const toggleKeep = (index) => {
  const newKept = [...kept];
  newKept[index] = !newKept[index];
  setKept(newKept);
};

const rollDice = () => {
  if (rollsLeft === 0) return;
  const newDice = dice.map((d, i) => 
    (kept[i] && d !== null ? d : rollDie())
  );
  setDice(newDice);
  setRollsLeft(rollsLeft - 1);
};
          </code></pre>
          <aside class="notes">
            <strong>Lukas:</strong> Die W√ºrfel k√∂nnen per Klick gehalten oder wieder freigegeben werden. 
            Das wird √ºber die Funktion <code>toggleKeep</code> gesteuert. 
            Beim W√ºrfeln bleiben die gehaltenen W√ºrfel erhalten, die anderen werden neu geworfen. 
            Das ist genau wie beim echten Kniffel und sorgt f√ºr ein authentisches Spielgef√ºhl. 
            Die Logik ist so aufgebaut, dass keine unzul√§ssigen Aktionen m√∂glich sind, zum Beispiel kann man nicht mehr w√ºrfeln, wenn die drei W√ºrfe aufgebraucht sind.
          </aside>
        </section>

        <section>
          <h3>Live Score Vorschau</h3>
          <pre><code class="language-js" data-trim>
&lt;div&gt;
  &#123;categories.map((cat) =&gt; &#123;
    const isChosen = scores[cat] !== null;
    const allRolled = dice.every((d) =&gt; d !== null);
    const previewScore = !isChosen &amp;&amp; allRolled 
      ? calculateScore(cat, dice) : null;
    
    return (
      &lt;button
        key=&#123;cat&#125;
        disabled=&#123;isChosen || !allRolled&#125;
        onClick=&#123;() =&gt; scoreCategory(cat)&#125;
      &gt;
        &#123;cat&#125;: &#123;isChosen ? scores[cat] : previewScore ?? "-"&#125;
      &lt;/button&gt;
    );
  &#125;)&#125;
&lt;/div&gt;
          </code></pre>
          <aside class="notes">
            <strong>Camille:</strong> 
            W√§hrend des Spiels sieht man immer eine Vorschau, wie viele Punkte man in jeder Kategorie bekommen w√ºrde, wenn man sie jetzt ausw√§hlt. 
            Das wird dynamisch berechnet, sobald alle W√ºrfel geworfen wurden. 
            Die Kategorien, die schon vergeben sind, sind deaktiviert. 
            Das macht die Bedienung sehr komfortabel und hilft, die beste Entscheidung zu treffen.
          </aside>
        </section>
      </section>

      <!-- Backend API -->
      <section>
        <section>
          <h2>üîå Backend API</h2>
          <p>Express.js Server mit SQLite & Prisma</p>
          <aside class="notes">
            <strong>Lars:</strong> Das Backend basiert auf Express.js und speichert die Daten in einer SQLite-Datenbank. 
            Die Kommunikation l√§uft √ºber eine REST-API.
          </aside>
        </section>

        <section>
          <h2>Session-basierte Authentifizierung</h2>
          <pre><code class="language-js" data-trim>
// server/routes/auth.js
router.post("/login", asyncHandler(async (req, res) => {
  const { username, password } = req.body;
  const user = await prisma.user.findUnique({ where: { username } });
  
  if (user && await bcrypt.compare(password, user.password)) {
    req.session.userId = user.id;
    req.session.save(error => {
      if(error) return res.status(500).json({ error: ERROR_MESSAGES.INTERNAL });
      res.json({ success: true, user: { id: user.id, username: user.username } });
    });
  } else {
    res.status(401).json({ error: ERROR_MESSAGES.INVALID_CREDENTIALS });
  }
}));
          </code></pre>
          <aside class="notes">
            <strong>Lukas:</strong> Die Authentifizierung l√§uft √ºber Sessions. 
            Beim Login wird gepr√ºft, ob der Nutzername existiert und das Passwort korrekt ist. 
            Wenn ja, wird die User-ID in der Session gespeichert. 
            Dadurch bleibt der Nutzer auch nach einem Neuladen der Seite eingeloggt. 
            Fehler wie falsches Passwort oder nicht existierender Nutzer werden mit passenden Fehlermeldungen beantwortet. 
            Die Sessions werden serverseitig gespeichert, was f√ºr zus√§tzliche Sicherheit sorgt.
          </aside>
        </section>

        <section>
          <h3>Score speichern</h3>
          <pre><code class="language-js" data-trim>
// Submit a new score for the logged-in user.
router.post("/score", isAuthenticated, asyncHandler(async (req, res) => {
  const { value } = req.body;
  await prisma.score.create({ data: { value, userId: req.session.userId } });
  res.json({ success: true });
}));

// Get top 10 highscores across all users.
router.get("/highscores", asyncHandler(async (req, res) => {
  const scores = await prisma.score.findMany({
    orderBy: { value: "desc" },
    take: 10,
    include: { user: true }
  });
  res.json(scores);
}));
          </code></pre>
          <aside class="notes">
            <strong>Camille:</strong> Nach jedem Spiel wird der Score automatisch an das Backend gesendet. 
            Der Endpunkt <code>/score</code> speichert den Score zusammen mit der User-ID in der Datenbank. 
            √úber <code>/highscores</code> k√∂nnen die Top 10 Scores abgerufen werden, inklusive Nutzernamen. 
            Die Highscore-Liste wird nach jedem neuen Score aktualisiert. 
            Au√üerdem gibt es einen Endpunkt, um die eigene Spielhistorie abzurufen, sodass jeder Nutzer seine bisherigen Spiele sehen kann.
          </aside>
        </section>

        <section>
          <h3>Prisma Schema</h3>
          <pre><code class="language-js" data-trim>
model User {
  id       Int     @id @default(autoincrement())
  username String  @unique
  password String
  scores   Score[]
}

model Score {
  id     Int      @id @default(autoincrement())
  value  Int
  date   DateTime @default(now())
  user   User     @relation(fields: [userId], references: [id])
  userId Int
}
          </code></pre>
          <aside class="notes">
            <strong>Lars:</strong> Das Prisma-Schema definiert die Datenbankstruktur. 
            Es gibt ein User-Modell mit eindeutiger ID, Nutzernamen und Passwort. 
            Jeder User kann mehrere Scores haben, die im Score-Modell gespeichert werden. 
            Jeder Score hat eine Punktzahl, ein Datum und eine Referenz auf den User. 
            Das macht es einfach, die Highscore-Liste und die eigene Spielhistorie zu verwalten. 
            Prisma sorgt daf√ºr, dass die Datenbank immer konsistent bleibt und Migrationen einfach durchgef√ºhrt werden k√∂nnen.
          </aside>         
        </section>
      </section>

      <!-- Aufgabenverteilung -->
      <section>
        <h2>üë• Aufgabenverteilung</h2>
        <div class="team-roles">
          <div>
            <h4>Camille</h4>
            <ul>
              <li>Backend-Entwicklung</li>
              <li>Datenbank-Design</li>
              <li>API-Endpoints</li>
              <li>Authentifizierung</li>
            </ul>
          </div>
          <div>
            <h4>Lars</h4>
            <ul>
              <li>Frontend-Entwicklung</li>
              <li>Spiellogik</li>
              <li>React Components</li>
              <li>UI/UX Design</li>
            </ul>
          </div>
          <div>
            <h4>Lukas</h4>
            <ul>
              <li>Testing & Debugging</li>
              <li>Styling & Layout</li>
              <li>Dokumentation</li>
              <li>Deployment</li>
            </ul>
          </div>
        </div>
        <aside class="notes">
          <strong>Lukas:</strong> Die Aufgaben waren klar verteilt: 
          Camille hat das Backend entwickelt, das Datenbankmodell entworfen und die API-Endpunkte gebaut. 
          Lars war f√ºr das Frontend, die Spiellogik und das UI/UX-Design zust√§ndig. 
          Ich habe mich um Testing, Styling, Dokumentation und das Deployment gek√ºmmert. 
          Durch diese klare Aufteilung konnten wir effizient arbeiten und uns gegenseitig unterst√ºtzen.
        </aside>
      </section>

      <!-- Live Demo -->
      <section>
        <h2>üöÄ Live Demo</h2>
        <h3>Funktionen in Aktion</h3>
        <ol>
          <li class="fragment">Benutzer registrieren</li>
          <li class="fragment">Kniffel spielen</li>
          <li class="fragment">Score speichern</li>
          <li class="fragment">Highscore anzeigen</li>
          <li class="fragment">Eigene Spielhistorie ansehen</li>
        </ol>
        <aside class="notes">
          <strong>Camille:</strong> Jetzt zeigen wir die App live. 
          Wir registrieren einen neuen Nutzer, spielen eine Runde Kniffel, speichern den Score und schauen uns die Highscore-Liste und die eigene Spielhistorie an. 
          So seht ihr alle wichtigen Funktionen in Aktion.
        </aside>
      </section>

      <!-- Herausforderungen & L√∂sungen -->
      <section>
        <h2>‚ö† Herausforderungen</h2>
        <ul>
          <li class="fragment">Komplexe Muster-Erkennung f√ºr Stra√üen</li>
          <li class="fragment">State Management zwischen W√ºrfeln, Kategorien und Scores</li>
          <li class="fragment">Session Handling & CORS</li>
          <li class="fragment">W√ºrfel-Holding zwischen W√ºrfen</li>
          <li class="fragment">User-Score Verkn√ºpfung mit Prisma</li>
        </ul>
        <aside class="notes">
          <strong>Lars:</strong> Es gab einige Herausforderungen: 
          Die Erkennung von kleinen und gro√üen Stra√üen war algorithmisch anspruchsvoll. 
          Das State Management im Frontend musste sauber zwischen W√ºrfeln, Kategorien und Scores unterscheiden. 
          Die Sessions und das CORS-Handling im Backend mussten sicher und zuverl√§ssig funktionieren. 
          Das Halten der W√ºrfel zwischen den W√ºrfen musste intuitiv und fehlerfrei laufen. 
          Und schlie√ülich mussten wir sicherstellen, dass jeder Score eindeutig dem richtigen Nutzer zugeordnet wird.
        </aside>
      </section>

      <section>
        <h2>üí° L√∂sungsans√§tze</h2>
        <ul>
          <li class="fragment">Bin√§r-Pattern Matching f√ºr Stra√üen</li>
          <li class="fragment">React useEffect f√ºr Score-Speichern</li>
          <li class="fragment">AsyncHandler f√ºr Error-Handling</li>
          <li class="fragment">Middleware-Chain f√ºr Auth</li>
          <li class="fragment">Preview-Scores f√ºr bessere UX</li>
        </ul>
        <aside class="notes">
          <strong>Lukas:</strong> Unsere L√∂sungen: 
          F√ºr die Stra√üen-Erkennung haben wir Bin√§r-Pattern-Matching verwendet, was sehr effizient ist. 
          Das automatische Speichern des Scores am Spielende l√§uft √ºber einen React useEffect-Hook. 
          F√ºr das Error-Handling im Backend nutzen wir einen AsyncHandler, der Fehler zentral abf√§ngt. 
          Die Authentifizierung ist als Middleware-Kette umgesetzt, sodass alle gesch√ºtzten Endpunkte sicher sind. 
          Und die Live-Vorschau der Punkte sorgt f√ºr eine bessere User Experience.
        </aside>
      </section>

      <!-- Reflexion -->
      <section>
        <section>
          <h2>ü§î Reflexion</h2>
          <aside class="notes">
            <strong>Camille:</strong> Zum Abschluss reflektieren wir, was im Projekt besonders gut lief. 
          </aside>
        </section>
        
        <section>
          <h3>‚úÖ Was lief gut?</h3>
          <ul>
            <li class="fragment">Klare Aufgabenverteilung im Team</li>
            <li class="fragment">Moderne Tech-Stack Wahl</li>
            <li class="fragment">Strukturierte Entwicklung</li>
            <li class="fragment">Alle Pflichtfunktionen implementiert</li>
            <li class="fragment">Responsive Design erreicht</li>
          </ul>
          <aside class="notes">
            <strong>Lars:</strong> Besonders gut war die klare Aufgabenverteilung im Team. 
            Jeder wusste, was zu tun ist, und wir konnten uns gegenseitig unterst√ºtzen. 
            Die Wahl des Tech-Stacks hat sich bew√§hrt, weil wir schnell und flexibel entwickeln konnten. 
            Die Entwicklung war sehr strukturiert, mit regelm√§√üigen Abstimmungen und Code-Reviews. 
            Wir haben alle Pflichtfunktionen wie geplant umgesetzt und das responsive Design sorgt daf√ºr, dass die App √ºberall gut aussieht.
          </aside>
        </section>
      </section>

      <!-- Erweiterungen -->
      <section>
        <h3>üöÄ M√∂gliche Erweiterungen</h3>
        <ul>
          <li class="fragment">Multiplayer-Funktionalit√§t</li>
          <li class="fragment">Erweiterte Statistiken</li>
          <li class="fragment">Mobile App</li>
          <li class="fragment">Verschiedene Spielvarianten</li>
          <li class="fragment">Social Features</li>
        </ul>
        <aside class="notes">
          <strong>Lukas:</strong> F√ºr die Zukunft gibt es viele M√∂glichkeiten zur Erweiterung. 
          Wir k√∂nnten eine Multiplayer-Funktion einbauen, damit mehrere Nutzer gleichzeitig spielen k√∂nnen. 
          Erweiterte Statistiken w√§ren spannend, zum Beispiel Durchschnittsscore oder h√§ufigste Kategorien. 
          Eine mobile App w√§re ein n√§chster Schritt, um noch mehr Nutzer zu erreichen. 
          Au√üerdem k√∂nnten wir verschiedene Spielvarianten oder Social Features wie Freundeslisten und Challenges erg√§nzen.
        </aside>
      </section>

      <section>
        <h2>üéâ Danke f√ºr die Aufmerksamkeit!</h2>
        <p>Fragen?</p>
        <p style="margin-top:2em;"><small>GitHub & Projektlink auf Anfrage</small></p>
        <aside class="notes">
          <strong>Camille:</strong> Vielen Dank f√ºr die Aufmerksamkeit! Wir freuen uns auf euer Feedback.
        </aside>
      </section>
    </div>
  </div>

  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>

  <script>
    Reveal.initialize({
      hash: true,
      plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ],
      transition: 'slide',
      transitionSpeed: 'default',
      backgroundTransition: 'fade',
    });
  </script>
</body>
</html>